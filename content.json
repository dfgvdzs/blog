{"meta":{"title":"Hexo","subtitle":"","description":"","author":"tch","url":"https://dfgvdzs.github.io/blog","root":"/blog/"},"pages":[],"posts":[{"title":"mybatis","slug":"mybatis","date":"2021-04-17T07:50:04.000Z","updated":"2021-04-17T09:07:46.879Z","comments":true,"path":"2021/04/17/mybatis/","link":"","permalink":"https://dfgvdzs.github.io/blog/2021/04/17/mybatis/","excerpt":"环境： JDK1.8 Mysql 5.7 maven 3.6.1 IDEA","text":"环境： JDK1.8 Mysql 5.7 maven 3.6.1 IDEA 回顾： JDBC Mysql Java基础 Maven Junit SSM框架：配置文件的。 最好的方式：看官网文档； 1、简介1.1、什么是Mybatis MyBatis 是一款优秀的持久层框架 它支持定制化 SQL、存储过程以及高级映射。 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。 MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。 2013年11月迁移到Github。 如何获得Mybatis？ maven仓库： 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt;&lt;/dependency&gt; Github ： https://github.com/mybatis/mybatis-3/releases 中文文档：https://mybatis.org/mybatis-3/zh/index.html 1.2、持久化数据持久化 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库(Jdbc)，io文件持久化。 生活：冷藏. 罐头。 为什么需要需要持久化？ 有一些对象，不能让他丢掉。 内存太贵了 1.3、持久层Dao层，Service层，Controller层…. 完成持久化工作的代码块 层界限十分明显。 1.4 为什么需要Mybatis？ 帮助程序猿将数据存入到数据库中。 方便 传统的JDBC代码太复杂了。简化。框架。自动化。 不用Mybatis也可以。更容易上手。 技术没有高低之分 优点： 简单易学 灵活 sql和代码的分离，提高了可维护性。 提供映射标签，支持对象与数据库的orm字段关系映射 提供对象关系映射标签，支持对象关系组建维护 提供xml标签，支持编写动态sql。 最重要的一点：使用的人多！ Spring SpringMVC SpringBoot 2、第一个Mybatis程序思路：搭建环境–&gt;导入Mybatis–&gt;编写代码–&gt;测试！ 2.1、搭建环境搭建数据库 1234567891011121314CREATE DATABASE `mybatis`;USE `mybatis`;CREATE TABLE `user`( `id` INT(20) NOT NULL PRIMARY KEY, `name` VARCHAR(30) DEFAULT NULL, `pwd` VARCHAR(30) DEFAULT NULL)ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT INTO `user`(`id`,`name`,`pwd`) VALUES (1,&#x27;狂神&#x27;,&#x27;123456&#x27;),(2,&#x27;张三&#x27;,&#x27;123456&#x27;),(3,&#x27;李四&#x27;,&#x27;123890&#x27;) 新建项目 新建一个普通的maven项目 删除src目录 导入maven依赖 1234567891011121314151617181920212223 &lt;!--导入依赖--&gt;&lt;dependencies&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis--&gt; &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.2、创建一个模块 编写mybatis的核心配置文件 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!--configuration核心配置文件--&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;/configuration&gt; 编写mybatis工具类 12345678910111213141516171819202122232425//sqlSessionFactory --&gt; sqlSessionpublic class MybatisUtils &#123; private static SqlSessionFactory sqlSessionFactory; static&#123; try &#123; //使用Mybatis第一步：获取sqlSessionFactory对象 String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。 // SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。 public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(); &#125;&#125; 2.3、编写代码 实体类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.kuang.pojo;//实体类public class User &#123; private int id; private String name; private String pwd; public User() &#123; &#125; public User(int id, String name, String pwd) &#123; this.id = id; this.name = name; this.pwd = pwd; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getPwd() &#123; return pwd; &#125; public void setPwd(String pwd) &#123; this.pwd = pwd; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, pwd=&#x27;&quot; + pwd + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; Dao接口 123public interface UserDao &#123; List&lt;User&gt; getUserList();&#125; 接口实现类由原来的UserDaoImpl转变为一个 Mapper配置文件. 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!--namespace=绑定一个对应的Dao/Mapper接口--&gt;&lt;mapper namespace=&quot;com.kuang.dao.UserDao&quot;&gt;&lt;!--select查询语句--&gt; &lt;select id=&quot;getUserList&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from mybatis.user &lt;/select&gt;&lt;/mapper&gt; 2.4、测试注意点： org.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry. MapperRegistry是什么？ 核心配置文件中注册 mappers junit测试 1234567891011121314151617181920@Testpublic void test()&#123; //第一步：获得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //方式一：getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List&lt;User&gt; userList = userDao.getUserList(); for (User user : userList) &#123; System.out.println(user); &#125; //关闭SqlSession sqlSession.close();&#125; 你们可以能会遇到的问题： 配置文件没有注册 绑定接口错误。 方法名不对 返回类型不对 Maven导出资源问题 3、CRUD1、namespacenamespace中的包名要和 Dao/mapper 接口的包名一致！ 2、select选择，查询语句; id : 就是对应的namespace中的方法名； resultType：Sql语句执行的返回值！ parameterType ： 参数类型！ 编写接口 12//根据ID查询用户User getUserById(int id); 编写对应的mapper中的sql语句 1234&lt;select id=&quot;getUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select * from mybatis.user where id = #&#123;id&#125;&lt;/select&gt; 测试 123456789101112@Testpublic void getUserById() &#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); sqlSession.close();&#125; 3、Insert1234&lt;!--对象中的属性，可以直接取出来--&gt;&lt;insert id=&quot;addUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; insert into mybatis.user (id, name, pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;pwd&#125;);&lt;/insert&gt; 4、update1234&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.kuang.pojo.User&quot;&gt; update mybatis.user set name=#&#123;name&#125;,pwd=#&#123;pwd&#125; where id = #&#123;id&#125; ;&lt;/update&gt; 5、Delete123&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from mybatis.user where id = #&#123;id&#125;;&lt;/delete&gt; 注意点： 增删改需要提交事务！ 6、分析错误 标签不要匹配错 resource 绑定mapper，需要使用路径！ 程序配置文件必须符合规范！ NullPointerException，没有注册到资源! 输出的xml文件中存在中文乱码问题！ maven资源没有导出问题！ 7、万能Map假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！ 123//万能的Mapint addUser2(Map&lt;String,Object&gt; map); 12345&lt;!--对象中的属性，可以直接取出来 传递map的key--&gt;&lt;insert id=&quot;addUser&quot; parameterType=&quot;map&quot;&gt; insert into mybatis.user (id, pwd) values (#&#123;userid&#125;,#&#123;passWord&#125;);&lt;/insert&gt; 1234567891011121314151617@Testpublic void addUser2()&#123; SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;userid&quot;,5); map.put(&quot;passWord&quot;,&quot;2222333&quot;); mapper.addUser2(map); sqlSession.close();&#125; Map传递参数，直接在sql中取出key即可！ 【parameterType=”map”】 对象传递参数，直接在sql中取对象的属性即可！【parameterType=”Object”】 只有一个基本类型参数的情况下，可以直接在sql中取到！ 多个参数用Map，或者注解！ 8、思考题模糊查询怎么写？ Java代码执行的时候，传递通配符 % % 1List&lt;User&gt; userList = mapper.getUserLike(&quot;%李%&quot;); 在sql拼接中使用通配符！ 1select * from mybatis.user where name like &quot;%&quot;#&#123;value&#125;&quot;%&quot; 4、配置解析1、核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 12345678910111213configuration（配置）properties（属性）settings（设置）typeAliases（类型别名）typeHandlers（类型处理器）objectFactory（对象工厂）plugins（插件）environments（环境配置）environment（环境变量）transactionManager（事务管理器）dataSource（数据源）databaseIdProvider（数据库厂商标识）mappers（映射器） 2、环境配置（environments）MyBatis 可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 学会使用配置多套运行环境！ Mybatis默认的事务管理器就是 JDBC ， 连接池 ： POOLED 3、属性（properties）我们可以通过properties属性来实现引用配置文件 这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。【db.properties】 编写一个配置文件 db.properties 1234driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8username=rootpassword=123456 在核心配置文件中映入 123456&lt;!--引入外部配置文件--&gt;&lt;properties resource=&quot;db.properties&quot;&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;pwd&quot; value=&quot;11111&quot;/&gt;&lt;/properties&gt; 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，优先使用外部配置文件的！ 4、类型别名（typeAliases） 类型别名是为 Java 类型设置一个短的名字。‘ 存在的意义仅在于用来减少类完全限定名的冗余。 1234&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;typeAlias type=&quot;com.kuang.pojo.User&quot; alias=&quot;User&quot;/&gt;&lt;/typeAliases&gt; 也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如： 扫描实体类的包，它的默认别名就为这个类的 类名，首字母小写！ 1234&lt;!--可以给实体类起别名--&gt;&lt;typeAliases&gt; &lt;package name=&quot;com.kuang.pojo&quot;/&gt;&lt;/typeAliases&gt; 在实体类比较少的时候，使用第一种方式。 如果实体类十分多，建议使用第二种。 第一种可以DIY别名，第二种则·不行·，如果非要改，需要在实体上增加注解 12@Alias(&quot;user&quot;)public class User &#123;&#125; 5、设置这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 6、其他配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins插件 mybatis-generator-core mybatis-plus 通用mapper 7、映射器（mappers）MapperRegistry：注册绑定我们的Mapper文件； 方式一： 【推荐使用】 1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;mapper resource=&quot;com/kuang/dao/UserMapper.xml&quot;/&gt;&lt;/mappers&gt; 方式二：使用class文件绑定注册 1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt;&lt;/mappers&gt; 注意点： 接口和他的Mapper配置文件必须同名！ 接口和他的Mapper配置文件必须在同一个包下！ 方式三：使用扫描包进行注入绑定 1234&lt;!--每一个Mapper.XML都需要在Mybatis核心配置文件中注册！--&gt;&lt;mappers&gt; &lt;package name=&quot;com.kuang.dao&quot;/&gt;&lt;/mappers&gt; 注意点： 接口和他的Mapper配置文件必须同名！ 接口和他的Mapper配置文件必须在同一个包下！ 练习时间： 将数据库配置文件外部引入 实体类别名 保证UserMapper 接口 和 UserMapper .xml 改为一致！并且放在同一个包下！ 8、生命周期和作用域 生命周期，和作用域，是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuilder： 一旦创建了 SqlSessionFactory，就不再需要它了 局部变量 SqlSessionFactory： 说白了就是可以想象为 ：数据库连接池 SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 因此 SqlSessionFactory 的最佳作用域是应用作用域。 最简单的就是使用单例模式或者静态单例模式。 SqlSession 连接到连接池的一个请求！ SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭，否则资源被占用！ 这里面的每一个Mapper，就代表一个具体的业务！ 5、解决属性名和字段名不一致的问题1、 问题数据库中的字段 新建一个项目，拷贝之前的，测试实体类字段不一致的情况 123456public class User &#123; private int id; private String name; private String password;&#125; 测试出现问题 123// select * from mybatis.user where id = #&#123;id&#125;//类型处理器// select id,name,pwd from mybatis.user where id = #&#123;id&#125; 解决方法： 起别名 123&lt;select id=&quot;getUserById&quot; resultType=&quot;com.kuang.pojo.User&quot;&gt; select id,name,pwd as password from mybatis.user where id = #&#123;id&#125;&lt;/select&gt; 2、resultMap结果集映射 12id name pwdid name password 1234567891011&lt;!--结果集映射--&gt;&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!--column数据库中的字段，property实体类中的属性--&gt; &lt;result column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;pwd&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getUserById&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user where id = #&#123;id&#125;&lt;/select&gt; resultMap 元素是 MyBatis 中最重要最强大的元素 ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。 ResultMap 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。 如果世界总是这么简单就好了。 6、日志6.1、日志工厂如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！ 曾经：sout 、debug 现在：日志工厂！ SLF4J LOG4J 【掌握】 LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING 【掌握】 NO_LOGGING 在Mybatis中具体使用那个一日志实现，在设置中设定！ STDOUT_LOGGING标准日志输出 在mybatis核心配置文件中，配置我们的日志！ 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; 6.2、Log4j什么是Log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。 先导入log4j的包 123456&lt;!-- https://mvnrepository.com/artifact/log4j/log4j --&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt; log4j.properties 123456789101112131415161718192021222324#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/kuang.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 配置log4j为日志的实现 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;&quot;/&gt;&lt;/settings&gt; Log4j的使用！，直接测试运行刚才的查询 简单使用 在要使用Log4j 的类中，导入包 import org.apache.log4j.Logger; 日志对象，参数为当前类的class 1static Logger logger = Logger.getLogger(UserDaoTest.class); 日志级别 123logger.info(&quot;info:进入了testLog4j&quot;);logger.debug(&quot;debug:进入了testLog4j&quot;);logger.error(&quot;error:进入了testLog4j&quot;); 7、分页思考：为什么要分页？ 减少数据的处理量 7.1、使用Limit分页12语法：SELECT * from user limit startIndex,pageSize;SELECT * from user limit 3; #[0,n] 使用Mybatis实现分页，核心SQL 接口 12//分页List&lt;User&gt; getUserByLimit(Map&lt;String,Integer&gt; map); Mapper.xml 1234&lt;!--//分页--&gt;&lt;select id=&quot;getUserByLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user limit #&#123;startIndex&#125;,#&#123;pageSize&#125;&lt;/select&gt; 测试 1234567891011121314151617@Testpublic void getUserByLimit()&#123;SqlSession sqlSession = MybatisUtils.getSqlSession();UserMapper mapper = sqlSession.getMapper(UserMapper.class);HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(&quot;startIndex&quot;,1); map.put(&quot;pageSize&quot;,2); List&lt;User&gt; userList = mapper.getUserByLimit(map); for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close(); &#125; 7.2、RowBounds分页不再使用SQL实现分页 接口 12//分页2List&lt;User&gt; getUserByRowBounds(); mapper.xml 1234&lt;!--分页2--&gt;&lt;select id=&quot;getUserByRowBounds&quot; resultMap=&quot;UserMap&quot;&gt; select * from mybatis.user&lt;/select&gt; 测试 12345678910111213141516@Testpublic void getUserByRowBounds()&#123;SqlSession sqlSession = MybatisUtils.getSqlSession();//RowBounds实现RowBounds rowBounds = new RowBounds(1, 2);//通过Java代码层面实现分页List&lt;User&gt; userList = sqlSession.selectList(&quot;com.kuang.dao.UserMapper.getUserByRowBounds&quot;,null,rowBounds); for (User user : userList) &#123; System.out.println(user); &#125; sqlSession.close(); &#125; 7.3、分页插件 了解即可，万一 以后公司的架构师，说要使用，你需要知道它是什么东西！ 8、使用注解开发8.1、面向接口编程- 大家之前都学过面向对象编程，也学习过接口，但在真正的开发中，很多时候我们会选择面向接口编程- 根本原因 : ==解耦== , 可拓展 , 提高复用 , 分层开发中 , 上层不用管具体的实现 , 大家都遵守共同的标准 , 使得开发变得容易 , 规范性更好- 在一个面向对象的系统中，系统的各种功能是由许许多多的不同对象协作完成的。在这种情况下，各个对象内部是如何实现自己的,对系统设计人员来讲就不那么重要了；- 而各个对象之间的协作关系则成为系统设计的关键。小到不同类之间的通信，大到各模块之间的交互，在系统设计之初都是要着重考虑的，这也是系统设计的主要工作内容。面向接口编程就是指按照这种思想来编程。 关于接口的理解 - 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。- 接口的本身反映了系统设计人员对系统的抽象理解。- 接口应有两类： - 第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)； - 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；- 一个体有可能有多个抽象面。抽象体与抽象面是有区别的。 三个面向区别 - 面向对象是指，我们考虑问题时，以对象为单位，考虑它的属性及方法 .- 面向过程是指，我们考虑问题时，以一个具体的流程（事务过程）为单位，考虑它的实现 .- 接口设计与非接口设计是针对复用技术而言的，与面向对象（过程）不是一个问题.更多的体现就是对系统整体的架构 8.2、使用注解开发 注解在接口上实现 12@Select(&quot;select * from user&quot;)List&lt;User&gt; getUsers(); 需要再核心配置文件中绑定接口！ 1234&lt;!--绑定接口--&gt;&lt;mappers&gt; &lt;mapper class=&quot;com.kuang.dao.UserMapper&quot;/&gt;&lt;/mappers&gt; 测试 本质：反射机制实现 底层：动态代理！ Mybatis详细的执行流程！ 8.3、CRUD我们可以在工具类创建的时候实现自动提交事务！ 123public static SqlSession getSqlSession()&#123; return sqlSessionFactory.openSession(true);&#125; 编写接口，增加注解 123456789101112131415161718192021public interface UserMapper &#123; @Select(&quot;select * from user&quot;) List&lt;User&gt; getUsers(); // 方法存在多个参数，所有的参数前面必须加上 @Param(&quot;id&quot;)注解 @Select(&quot;select * from user where id = #&#123;id&#125;&quot;) User getUserByID(@Param(&quot;id&quot;) int id); @Insert(&quot;insert into user(id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;) int addUser(User user); @Update(&quot;update user set name=#&#123;name&#125;,pwd=#&#123;password&#125; where id = #&#123;id&#125;&quot;) int updateUser(User user); @Delete(&quot;delete from user where id = #&#123;uid&#125;&quot;) int deleteUser(@Param(&quot;uid&quot;) int id);&#125; 测试类 【注意：我们必须要讲接口注册绑定到我们的核心配置文件中！】 关于@Param() 注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议大家都加上！ 我们在SQL中引用的就是我们这里的 @Param() 中设定的属性名！ #{} ${} 区别 9、Lombok12Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more. java library plugs build tools with one annotation your class 使用步骤： 在IDEA中安装Lombok插件！ 在项目中导入lombok的jar包 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.10&lt;/version&gt;&lt;/dependency&gt; 在实体类上加注解即可！ 123@Data@AllArgsConstructor@NoArgsConstructor 1234567891011121314@Getter and @Setter@FieldNameConstants@ToString@EqualsAndHashCode@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger@Data@Builder@Singular@Delegate@Value@Accessors@Wither@SneakyThrows 说明： 123456@Data：无参构造，get、set、tostring、hashcode，equals@AllArgsConstructor@NoArgsConstructor@EqualsAndHashCode@ToString@Getter 10、多对一处理多对一： 多个学生，对应一个老师 对于学生这边而言， 关联 .. 多个学生，关联一个老师 【多对一】 对于老师而言， 集合 ， 一个老师，有很多学生 【一对多】 SQL： 123456789101112131415161718192021222324CREATE TABLE `teacher` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO teacher(`id`, `name`) VALUES (1, &#x27;秦老师&#x27;); CREATE TABLE `student` ( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, `tid` INT(10) DEFAULT NULL, PRIMARY KEY (`id`), KEY `fktid` (`tid`), CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;1&#x27;, &#x27;小明&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;2&#x27;, &#x27;小红&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;3&#x27;, &#x27;小张&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;4&#x27;, &#x27;小李&#x27;, &#x27;1&#x27;); INSERT INTO `student` (`id`, `name`, `tid`) VALUES (&#x27;5&#x27;, &#x27;小王&#x27;, &#x27;1&#x27;); 测试环境搭建 导入lombok 新建实体类 Teacher，Student 建立Mapper接口 建立Mapper.XML文件 在核心配置文件中绑定注册我们的Mapper接口或者文件！【方式很多，随心选】 测试查询是否能够成功！ 按照查询嵌套处理123456789101112131415161718192021&lt;!-- 思路: 1. 查询所有的学生信息 2. 根据查询出来的学生的tid，寻找对应的老师！ 子查询 --&gt;&lt;select id=&quot;getStudent&quot; resultMap=&quot;StudentTeacher&quot;&gt; select * from student&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;name&quot;/&gt; &lt;!--复杂的属性，我们需要单独处理 对象： association 集合： collection --&gt; &lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;Teacher&quot; select=&quot;getTeacher&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getTeacher&quot; resultType=&quot;Teacher&quot;&gt; select * from teacher where id = #&#123;id&#125;&lt;/select&gt; 按照结果嵌套处理1234567891011121314&lt;!--按照结果嵌套处理--&gt;&lt;select id=&quot;getStudent2&quot; resultMap=&quot;StudentTeacher2&quot;&gt; select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid = t.id;&lt;/select&gt;&lt;resultMap id=&quot;StudentTeacher2&quot; type=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;association property=&quot;teacher&quot; javaType=&quot;Teacher&quot;&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;/association&gt;&lt;/resultMap&gt; 回顾Mysql 多对一查询方式： 子查询 联表查询 11、一对多处理比如：一个老师拥有多个学生！ 对于老师而言，就是一对多的关系! 环境搭建 环境搭建，和刚才一样 实体类 123456789@Datapublic class Student &#123; private int id; private String name; private int tid;&#125; 12345678@Datapublic class Teacher &#123; private int id; private String name; //一个老师拥有多个学生 private List&lt;Student&gt; students;&#125; 按照结果嵌套处理123456789101112131415161718192021&lt;!--按结果嵌套查询--&gt;&lt;select id=&quot;getTeacher&quot; resultMap=&quot;TeacherStudent&quot;&gt; select s.id sid, s.name sname, t.name tname,t.id tid from student s,teacher t where s.tid = t.id and t.id = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent&quot; type=&quot;Teacher&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;tid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;tname&quot;/&gt; &lt;!--复杂的属性，我们需要单独处理 对象： association 集合： collection javaType=&quot;&quot; 指定属性的类型！ 集合中的泛型信息，我们使用ofType获取 --&gt; &lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&gt; &lt;result property=&quot;id&quot; column=&quot;sid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;sname&quot;/&gt; &lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&gt; &lt;/collection&gt;&lt;/resultMap&gt; 按照查询嵌套处理1234567891011&lt;select id=&quot;getTeacher2&quot; resultMap=&quot;TeacherStudent2&quot;&gt; select * from mybatis.teacher where id = #&#123;tid&#125;&lt;/select&gt;&lt;resultMap id=&quot;TeacherStudent2&quot; type=&quot;Teacher&quot;&gt; &lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Student&quot; select=&quot;getStudentByTeacherId&quot; column=&quot;id&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;getStudentByTeacherId&quot; resultType=&quot;Student&quot;&gt; select * from mybatis.student where tid = #&#123;tid&#125;&lt;/select&gt; 小结 关联 - association 【多对一】 集合 - collection 【一对多】 javaType &amp; ofType JavaType 用来指定实体类中属性的类型 ofType 用来指定映射到List或者集合中的 pojo类型，泛型中的约束类型！ 注意点： 保证SQL的可读性，尽量保证通俗易懂 注意一对多和多对一中，属性名和字段的问题！ 如果问题不好排查错误，可以使用日志 ， 建议使用 Log4j 慢SQL 1s 1000s 面试高频 Mysql引擎 InnoDB底层原理 索引 索引优化！ 12、动态 SQL==什么是动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句== 利用动态 SQL 这一特性可以彻底摆脱这种痛苦。 123456动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。ifchoose (when, otherwise)trim (where, set)foreach 搭建环境12345678CREATE TABLE `blog` ( `id` varchar(50) NOT NULL COMMENT &#x27;博客id&#x27;, `title` varchar(100) NOT NULL COMMENT &#x27;博客标题&#x27;, `author` varchar(30) NOT NULL COMMENT &#x27;博客作者&#x27;, `create_time` datetime NOT NULL COMMENT &#x27;创建时间&#x27;, `views` int(30) NOT NULL COMMENT &#x27;浏览量&#x27;) ENGINE=InnoDB DEFAULT CHARSET=utf8 创建一个基础工程 导包 编写配置文件 编写实体类 1234567891011@Datapublic class Blog &#123; private int id; private String title; private String author; private Date createTime; private int views; &#125; 编写实体类对应Mapper接口 和 Mapper.XML文件 IF123456789&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog where 1=1 &lt;if test=&quot;title != null&quot;&gt; and title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/select&gt; choose (when, otherwise)1234567891011121314151617&lt;select id=&quot;queryBlogChoose&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/when&gt; &lt;when test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/when&gt; &lt;otherwise&gt; and views = #&#123;views&#125; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt;&lt;/select&gt; trim (where,set)123456789select * from mybatis.blog&lt;where&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/where&gt; 12345678910111213&lt;update id=&quot;updateBlog&quot; parameterType=&quot;map&quot;&gt; update mybatis.blog &lt;set&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125;, &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; author = #&#123;author&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;&lt;/update&gt; ==所谓的动态SQL，本质还是SQL语句 ， 只是我们可以在SQL层面，去执行一个逻辑代码== if where ， set ， choose ，when SQL片段有的时候，我们可能会将一些功能的部分抽取出来，方便复用！ 使用SQL标签抽取公共的部分 12345678&lt;sql id=&quot;if-title-author&quot;&gt; &lt;if test=&quot;title != null&quot;&gt; title = #&#123;title&#125; &lt;/if&gt; &lt;if test=&quot;author != null&quot;&gt; and author = #&#123;author&#125; &lt;/if&gt;&lt;/sql&gt; 在需要使用的地方使用Include标签引用即可 123456&lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;include refid=&quot;if-title-author&quot;&gt;&lt;/include&gt; &lt;/where&gt;&lt;/select&gt; 注意事项： 最好基于单表来定义SQL片段！ 不要存在where标签 Foreach123456789select * from user where 1=1 and &lt;foreach item=&quot;id&quot; collection=&quot;ids&quot; open=&quot;(&quot; separator=&quot;or&quot; close=&quot;)&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;(id=1 or id=2 or id=3) 12345678910111213141516&lt;!-- select * from mybatis.blog where 1=1 and (id=1 or id = 2 or id=3) 我们现在传递一个万能的map ， 这map中可以存在一个集合！--&gt;&lt;select id=&quot;queryBlogForeach&quot; parameterType=&quot;map&quot; resultType=&quot;blog&quot;&gt; select * from mybatis.blog &lt;where&gt; &lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;and (&quot; close=&quot;)&quot; separator=&quot;or&quot;&gt; id = #&#123;id&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; ==动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了== 建议： 现在Mysql中写出完整的SQL,再对应的去修改成为我们的动态SQL实现通用即可！ 13、缓存 （了解）13.1、简介1234查询 ： 连接数据库 ，耗资源！ 一次查询的结果，给他暂存在一个可以直接取到的地方！--&gt; 内存 ： 缓存 我们再次查询相同数据的时候，直接走缓存，就不用走数据库了 什么是缓存 [ Cache ]？ 存在内存中的临时数据。 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率。 什么样的数据能使用缓存？ 经常查询并且不经常改变的数据。【可以使用缓存】 13.2、Mybatis缓存 MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。 MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。 为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 13.3、一级缓存 一级缓存也叫本地缓存： SqlSession 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必须再去查询数据库； 测试步骤： 开启日志！ 测试在一个Sesion中查询两次相同记录 查看日志输出 缓存失效的情况： 查询不同的东西 增删改操作，可能会改变原来的数据，所以必定会刷新缓存！ 查询不同的Mapper.xml 手动清理缓存！ 小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！ 一级缓存就是一个Map。 13.4、二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存； 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中； 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中； 新的会话查询信息，就可以从二级缓存中获取内容； 不同的mapper查出的数据会放在自己对应的缓存（map）中； 步骤： 开启全局缓存 12&lt;!--显示的开启全局缓存--&gt;&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; 在要使用二级缓存的Mapper中开启 12&lt;!--在当前Mapper.xml中使用二级缓存--&gt;&lt;cache/&gt; 也可以自定义参数 12345&lt;!--在当前Mapper.xml中使用二级缓存--&gt;&lt;cache eviction=&quot;FIFO&quot; flushInterval=&quot;60000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;/&gt; 测试 问题:我们需要将实体类序列化！否则就会报错！ 1Caused by: java.io.NotSerializableException: com.kuang.pojo.User 小结： 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中； 只有当会话提交，或者关闭的时候，才会提交到二级缓冲中！ 13.5、缓存原理 13.6、自定义缓存-ehcache1Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存 要在程序中使用ehcache，先要导包！ 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt;&lt;/dependency&gt; 在mapper中指定使用我们的ehcache缓存实现！ 12&lt;!--在当前Mapper.xml中使用二级缓存--&gt;&lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt; ehcache.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot; updateCheck=&quot;false&quot;&gt; &lt;!-- diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下： user.home – 用户主目录 user.dir – 用户当前工作目录 java.io.tmpdir – 默认临时文件路径 --&gt; &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt; &lt;defaultCache eternal=&quot;false&quot; maxElementsInMemory=&quot;10000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;259200&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;cache name=&quot;cloud_user&quot; eternal=&quot;false&quot; maxElementsInMemory=&quot;5000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;1800&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt; &lt;!-- defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。 --&gt; &lt;!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统当机时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。 --&gt;&lt;/ehcache&gt; Redis数据库来做缓存！ K-V 练习：29道练习题实战！","categories":[],"tags":[]},{"title":"spring","slug":"spring","date":"2021-04-17T07:00:05.000Z","updated":"2021-04-17T09:09:19.366Z","comments":true,"path":"2021/04/17/spring/","link":"","permalink":"https://dfgvdzs.github.io/blog/2021/04/17/spring/","excerpt":"1","text":"1 5. Spring配置5.1 别名 12&lt;!--如果添加了别名, 可以使用别名获得这个对象--&gt;&lt;alias name=&quot;user&quot; alias=&quot;user6&quot;/&gt; 5.2 Bean配置12345678&lt;bean id=&quot;user&quot; class=&quot;com.study.pojo.User&quot; name=&quot;user2 user3, user4; user5&quot;&gt; id: bean的唯一标识符, 也就是相当于我们学的对象名 class: bean 对应的全限定名(包名+类型) name: 也就是别名, 可以同时取多个别名--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.study.pojo.User&quot; name=&quot;user2 user3, user4; user5&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;1234&quot;/&gt;&lt;/bean&gt; 5.3 import一般用于团队开发, 可将多个配置文件导入合并为一个 假如有多人开发, 各个负责不同的类, 不同的类需要注册不同的bean中, 可使用import将所有人的beans.xml合并为一个总的 使用时, 直接使用总的配置即可 applicationContext.xml 123&lt;import resource=&quot;beans.xml&quot;/&gt;&lt;import resource=&quot;beans2.xml&quot;/&gt;&lt;import resource=&quot;beans3.xml&quot;/&gt; 1ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 6. 依赖注入6.1 构造器注入前面说过 6.2 Set方式注入(重点) 依赖注入: Set注入 依赖: bean对象的创建依赖容器 注入: bean对象中的所有属性, 由容器来注入 [环境搭建] 复杂类型 1234567891011public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 真实测试对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String, String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public String[] getBooks() &#123; return books; &#125; public void setBooks(String[] books) &#123; this.books = books; &#125; public List&lt;String&gt; getHobbys() &#123; return hobbys; &#125; public void setHobbys(List&lt;String&gt; hobbys) &#123; this.hobbys = hobbys; &#125; public Map&lt;String, String&gt; getCard() &#123; return card; &#125; public void setCard(Map&lt;String, String&gt; card) &#123; this.card = card; &#125; public Set&lt;String&gt; getGames() &#123; return games; &#125; public void setGames(Set&lt;String&gt; games) &#123; this.games = games; &#125; public String getWife() &#123; return wife; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; public Properties getInfo() &#123; return info; &#125; public void setInfo(Properties info) &#123; this.info = info; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, address=&quot; + address + &quot;, books=&quot; + Arrays.toString(books) + &quot;, hobbys=&quot; + hobbys + &quot;, card=&quot; + card + &quot;, games=&quot; + games + &quot;, wife=&#x27;&quot; + wife + &#x27;\\&#x27;&#x27; + &quot;, info=&quot; + info + &#x27;&#125;&#x27;; &#125;&#125; beans.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--第一种, 普通值注入 value--&gt; &lt;bean name=&quot;student&quot; class=&quot;com.study.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;StudentName&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 1234567public class MyTest &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Student student = (Student) context.getBean(&quot;student&quot;); System.out.println(student.getName()); &#125;&#125; 完善注入信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;address&quot; class=&quot;com.study.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;广西&quot;/&gt; &lt;/bean&gt; &lt;bean name=&quot;student&quot; class=&quot;com.study.pojo.Student&quot;&gt; &lt;!--第一种, 普通值注入 value--&gt; &lt;property name=&quot;name&quot; value=&quot;StudentName&quot;/&gt; &lt;!--第二种 Bean注入, ref--&gt; &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt; &lt;!--array--&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;三国&lt;/value&gt; &lt;value&gt;西游&lt;/value&gt; &lt;value&gt;水浒&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--List--&gt; &lt;property name=&quot;hobbys&quot;&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;电影&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Map--&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;身份证&quot; value=&quot;14556516351&quot;/&gt; &lt;entry key=&quot;银行卡&quot; value=&quot;1564654135165&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--Set--&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;CF&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--null--&gt; &lt;property name=&quot;wife&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;!--property--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;学号&quot;&gt;20180000&lt;/prop&gt; &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt; &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 6.3 拓展注入可以使用p命名空间和c命名空间 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--p命名空间 可以注入属性的值 property--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.study.pojo.User&quot; p:name=&quot;小明&quot; p:age=&quot;18&quot;/&gt; &lt;!--c命名空间 通过构造器注入: construct-args--&gt; &lt;bean id=&quot;user2&quot; class=&quot;com.study.pojo.User&quot; c:name=&quot;小明2&quot; c:age=&quot;18&quot;/&gt;&lt;/beans&gt; 注意: 不能直接使用, 需要导入xml约束 12xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 6.4 bean的作用域 单例模式 (Spring默认机制) 1&lt;bean id=&quot;user&quot; class=&quot;com.study.pojo.User&quot; p:name=&quot;小明&quot; p:age=&quot;18&quot; scope=&quot;singleton&quot;/&gt; 原型模式: 每次从容器get的时候, 都会产生一个新对象 1&lt;bean id=&quot;user&quot; class=&quot;com.study.pojo.User&quot; p:name=&quot;小明&quot; p:age=&quot;18&quot; scope=&quot;prototype&quot;/&gt; 其余的request, session, application, 这些只能在web开发中使用到 7. bean的自动装配 自动装配是Spring满足bean依赖一种方式 Spring会在上下文中自动寻找, 并自动给bean装配属性 在Spring中有三种装配的方式 在xml中显式的配置 在java中显式配置 隐式的自动装配bean (重要) 7.1 环境People类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.study.pojo;/** * @author tch * @date 2021/04/12 16:26:47 **/public class People &#123; private String name; private Cat cat; private Dog dog; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; @Override public String toString() &#123; return &quot;com.study.pojo.People&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, cat=&quot; + cat + &quot;, dog=&quot; + dog + &#x27;&#125;&#x27;; &#125;&#125; Cat类 12345public class Cat &#123; public void shout() &#123; System.out.println(&quot;miao~&quot;); &#125;&#125; Dog类 12345public class Dog &#123; public void shout() &#123; System.out.println(&quot;wang~&quot;); &#125;&#125; 7.2 byName自动装配byName: 会在容器上下文中查找, 和 自己对象 set方法 后 值 对应的 bean id 1234&lt;!--byName: 会在容器上下文中查找, 和自己对象set方法后值对应的 bean id--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.study.pojo.People&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;&lt;/bean&gt; 7.3 byType 自动装配byType: 会在容器上下文中查找, 和自己对象 属性类型相同 的 bean 1234&lt;!--byType: 会在容器上下文中查找, 和自己对象属性类型相同的 bean--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.study.pojo.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;&lt;/bean&gt; 小结: byName: 需要保证所有 bean 的 id 唯一, 并且这个bean需要和自动注入的属性的 set方法一致 byType: 需要保证所有 bean的 class唯一, 并且这个bean需要和自动注入的属性的 类型一致 7.4 使用注解实现自动装配JDK1.5支持注解 Spring2.5就支持了 ![image-20210412203949251](5. Spring.assets/image-20210412203949251.png) 使用注解须知: 导入约束: context 约束 ==配置注解的支持:== &lt;context:annotation-config/&gt; 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired注解 直接在属性上使用即可, 也可以在set方法上使用 使用Autowired, 可以不用再编写Set方法, 前提是这个自动装配的属性在ioc(Spring) 容器中存在, 且符合名字为byName 科普: 1@Nullable 字段标记了这个注解, 说明这个字段可以为null 123public @interface Autowired &#123; boolean required() default true;&#125; 测试代码 123456789public class People &#123; private String name; /*如果显式定义了Autowired的required属性为false, 说明对象可以为null, 否则不允许为空*/ @Autowired(required = false) private Cat cat; @Autowired private Dog dog;&#125; 如果@Autowired自动装配的环境复杂, 自动装配无法通过一个注解 @Autowired 完成时, 可以使用 @Qualifier(value = &quot;xxx&quot;) 去配合@Autowired 的使用, 指定一个唯一的bean对象注入 123456789101112public class People &#123; private String name; @Autowired @Qualifier(value = &quot;cat222&quot;) private Cat cat; @Autowired @Qualifier(value = &quot;dog222&quot;) private Dog dog;&#125; @Resource注解 1234567891011121314public class People &#123; private String name; @Resource(name = &quot;cat111&quot;) private Cat cat; @Resource private Dog dog; public String getName() &#123; return name; &#125;&#125; 小结 @Resource 和 @Autowired 的区别 都是用于自动装配, 都可以放在属性字段 @Autowired 通过byType的方式实现, 且必须要求这个对象存在 常用 @Resource 默认通过 byName 的方式实现, 如果找不到名字, 则通过byType实现, 如果两个都找不到的情况下 就报错 常用 执行顺序不同: @Autowired 通过byType的方式实现, @Resource 默认通过 byName的方式实现 8. 使用注解开发在使用spring4之后要使用注解开发, 必须要保证aop的包导入了 ![image-20210412215329084](5. Spring.assets/image-20210412215329084.png) 使用注解需要导入context约束, 增加注解的支持 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--配置注解的支持--&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 8.1 bean8.2 属性如何注入12345678910@Component //等价于 &lt;bean id=&quot;user&quot; class=&quot;com.study.pojo.User&quot;/&gt; @Component 组件public class User &#123; public String name; @Value(&quot;1233&quot;) //相当于 &lt;property name=&quot;name&quot; value=&quot;213&quot;/&gt; public void setName(String name) &#123; this.name = name; &#125;&#125; 8.3 衍生的注解@Component 有几个衍生注解, 在web开发中, 会按照mvc三层架构分层 dao @Repository service @service controller @Controller 这四个注解功能都是一样, 都是代表将某个类注册到Spring中, 装配 bean 8.4 自动装配123@Autowired: 自动装配类型 通过名字 如果Autowired不能唯一自动装配上属性, 则需要通过 @Qualifier(value = &quot;xxx&quot;) @Nullable: 字段标记了这个注解, 说明这个字段可以为null @Resource: 自动装配 通过名字, 类型 8.5 作用域==@Scope(“prototype”)== 1234567891011@Component //等价于 &lt;bean id=&quot;user&quot; class=&quot;com.study.pojo.User&quot;/&gt; @Component 组件@Scope(&quot;prototype&quot;)public class User &#123; public String name; @Value(&quot;1233&quot;) //相当于 &lt;property name=&quot;name&quot; value=&quot;213&quot;/&gt; public void setName(String name) &#123; this.name = name; &#125;&#125; 8.6 小结xml与注解: xml更加万能, 适用于任何场合, 维护简单方便 注解 不是自己的类使用不了, 维护相对复杂 xml与注解最佳实践: xml用来管理bean 注解只负责完成属性的注入 我们在使用的过程中, 只需要主要一个问题: 必须让注解生效, 就需要注解的支持 12345&lt;!--配置注解的支持--&gt;&lt;context:annotation-config/&gt;&lt;!--指定扫描的包, 这个包下的注解就会生效--&gt;&lt;context:component-scan base-package=&quot;com.study&quot;/&gt; 9. 使用java的方式配置Spring我们现在要完全不使用Spring的xml配置了, 全权交给java来做 JavaConfig是Spring的一个子项目, 在spring4之后, 他成了一个核心功能 pojo User : 123456789101112131415161718192021//这里这个注解的意思, 就是说明这个类被Spring接管了, 注册到容器中@Componentpublic class User &#123; private String name; public String getName() &#123; return name; &#125; @Value(&quot;1323&quot;) // 属性注入值 public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 配置文件 : MyConfig.java 123456789101112131415// 这个也会被Spring容器托管, 注册到容器中, 因为他本身就是一个@Component// @Configuration代表这是一个配置类, 就和我们之前看的 beans.xml一样@Configuration@ComponentScan(&quot;com.study.pojo&quot;)@Import(MyConfig2.class)public class MyConfig &#123; //注册一个bean, 就相当于我们之前写的一个bean标签 //这个方法的名字, 就相当于bean标签中的id属性 //这个方法的返回值, 就相当于bean标签中的class属性 @Bean public User getUser() &#123; return new User(); //就是要返回要注入到bean的对象 &#125;&#125; MyConfig2.java 1234@Configurationpublic class MyConfig2 &#123;&#125; 测试类 123456789public class MyTest &#123; public static void main(String[] args) &#123; //如果完全使用了配置类方式去做, 就只能通过AnnotationConfig 上下文来获取容器, 通过配置类的class对象加载 ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class); User getUser = (User) context.getBean(&quot;getUser&quot;); System.out.println(getUser.getName()); &#125;&#125; 这种纯java的配置方式, 在spring boot中随处可见 10. 代理模式为什么要学代理模式? ​ 因为这就是SpringAOP的底层 [SpringAOP 和 SpringMVC] 代理模式分类: 静态代理 动态代理 10.1 静态代理角色分析: 抽象角色 : 一般会使用接口或者抽象类来解决 真实角色 : 被代理的角色 代理角色 : 代理真实角色, 代理真实角色后, 我们一般会做一些附属操作 客户 : 访问代理对象的人 代码步骤 : 接口 123public interface Rent &#123; public void rent();&#125; 真实角色 123456public class Host implements Rent &#123; @Override public void rent() &#123; System.out.println(&quot;房东要出租房子!&quot;); &#125;&#125; 代理角色 1234567891011121314151617181920public class Proxy &#123; private Host host; public Proxy() &#123; &#125; public Proxy(Host host) &#123; this.host = host; &#125; public void rent() &#123; seeHouse(); host.rent(); &#125; //看房 public void seeHouse() &#123; System.out.println(&quot;看房&quot;); &#125;&#125; 客户端访问代理角色 123456789101112public class Client &#123; public static void main(String[] args) &#123; //房东出租房子 Host host = new Host(); //代理, 中介帮房东出租房子, 但是, 代理角色一般会有一些附属操作 Proxy proxy = new Proxy(host); //你, 不用面对房东, 直接找中介即可 proxy.rent(); &#125;&#125; 代理模式好处: 可以使真实角色的操作更纯粹, 不用去关注一些公共的业务 公共业务就交给代理角色, 实现业务的分工 公共业务发生扩展的时候, 方便集中管理 缺点: 一个真实角色就会产生一个代理角色, 代码量会翻倍, 开发效率会变低 10.2 加深理解代码: 接口 : 123456789public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; 真实角色 123456789101112131415161718192021public class UserServiceImpl implements UserService &#123; @Override public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;修改了一个用户&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询一个用户&quot;); &#125;&#125; 代理角色 12345678910111213141516171819202122232425262728293031323334353637public class UserServiceProxy implements UserService &#123; private UserService userService; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; @Override public void add() &#123; log(&quot;add&quot;); userService.add(); &#125; @Override public void delete() &#123; log(&quot;delete&quot;); userService.delete(); &#125; @Override public void update() &#123; log(&quot;update&quot;); userService.update(); &#125; @Override public void query() &#123; log(&quot;query&quot;); userService.query(); &#125; //日志方法 public void log(String msg) &#123; System.out.println(&quot;使用了&quot; + msg + &quot;方法&quot;); &#125;&#125; 客户端访问代理角色 123456789101112public class Client &#123; public static void main(String[] args) &#123; UserServiceImpl userService = new UserServiceImpl(); UserServiceProxy proxy = new UserServiceProxy(); proxy.setUserService(userService); proxy.add(); &#125;&#125; 聊聊AOP 10.3 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的, 不是我们直接写好的 动态代理分成两大类: 基于接口的动态代理, 基于类的动态代理 基于接口 — JDK动态代理 [我们在这里使用] 基于类: cglib java字节码实现: javasist 需要了解两个类: Proxy: 代理, invocationHandler: 调用处理程序 **动态代理的好处 : ** 可以使真实角色的操作更纯粹, 不用去关注一些公共的业务 公共业务就交给代理角色, 实现业务的分工 公共业务发生扩展的时候, 方便集中管理 一个动态代理类代理的是一个接口, 一般就是对应的一类业务 一个动态代理类可以代理多个类, 只要是实现了同一个接口即可 11. AOP11.1 什么是AOP 11.2 AOP在Spring中的作用 11.3 使用Spring实现Aop **重点 : ** 使用AOP织入, 需要导入一个依赖包 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 搭建环境: Log 1234567891011public class Log implements MethodBeforeAdvice &#123; /* * method 要执行的目标对象的方法 * args 参数 * target 目标对象 * */ @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(target.getClass().getName() + &quot;的&quot; + method.getName() + &quot;被执行了&quot;); &#125;&#125; AfterLog 123456public class AfterLog implements AfterReturningAdvice &#123; @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;执行了&quot; + method.getName() + &quot;方法, 返回结果为&quot; + returnValue); &#125;&#125; UserService接口 123456789public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; UserService实现类 123456789101112131415161718192021222324public class UserServiceImpl implements UserService &#123; @Override public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;更新了一个用户&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 11.3.1 方式1 使用Spring的API接口 ==主要SpringAPI接口实现== bean.xml 12345678910111213141516&lt;!--注册bean--&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.study.service.UserServiceImpl&quot;/&gt;&lt;bean id=&quot;log&quot; class=&quot;com.study.log.Log&quot;/&gt;&lt;bean id=&quot;afterLog&quot; class=&quot;com.study.log.AfterLog&quot;/&gt;&lt;!--方式1 : 使用原生Spring API接口--&gt;&lt;!--配置AOP: 需要导入aop的约束--&gt; &lt;aop:config&gt; &lt;!--切入点: expression:表达式, execution(要执行的位置! * * * * *)--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.study.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕增加--&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt; 11.3.2 方式2 自定义类来实现AOP 主要是切面定义 DiyPointcut类 123456789public class DiyPointcut &#123; public void before() &#123; System.out.println(&quot;=========方法执行前=======&quot;); &#125; public void after() &#123; System.out.println(&quot;=========方法执行后=======&quot;); &#125;&#125; bean.xml 123456789101112&lt;!--方式2--&gt;&lt;bean id=&quot;diy&quot; class=&quot;com.study.diy.DiyPointcut&quot;/&gt;&lt;aop:config&gt; &lt;!--自定义切面, ref 要引用的类--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.study.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--通知--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 11.3.3 方式3 使用注解实现 12345678910111213141516171819202122@Aspect //标注这个类是一个切面public class AnnotationPointCut &#123; @Before(&quot;execution( * com.study.service.UserServiceImpl.*(..))&quot;) public void before() &#123; System.out.println(&quot;===========方法执行前===========&quot;); &#125; @After(&quot;execution( * com.study.service.UserServiceImpl.*(..))&quot;) public void after() &#123; System.out.println(&quot;===========方法执行后===========&quot;); &#125; @Around(&quot;execution( * com.study.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println(&quot;环绕前&quot;); //执行方法 Object proceed = jp.proceed(); System.out.println(&quot;环绕后&quot;); &#125;&#125; bean.xml 1234&lt;!--方式三--&gt;&lt;bean id=&quot;annotationPointCut&quot; class=&quot;com.study.diy.AnnotationPointCut&quot;/&gt;&lt;!--开启注解支持--&gt;&lt;aop:aspectj-autoproxy/&gt;","categories":[],"tags":[]}],"categories":[],"tags":[]}