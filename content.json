{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://dfgvdzs.github.io/blog","root":"/blog/"},"pages":[],"posts":[{"title":"spring","slug":"spring","date":"2021-04-17T07:00:05.000Z","updated":"2021-04-17T07:46:56.180Z","comments":true,"path":"2021/04/17/spring/","link":"","permalink":"https://dfgvdzs.github.io/blog/2021/04/17/spring/","excerpt":"Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。 然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。","text":"Spring框架是由于软件开发的复杂性而创建的。Spring使用的是基本的JavaBean来完成以前只可能由EJB完成的事情。 然而，Spring的用途不仅仅限于服务器端的开发。从简单性、可测试性和松耦合性角度而言，绝大部分Java应用都可以从Spring中受益。 5. Spring配置5.1 别名 12&lt;!--如果添加了别名, 可以使用别名获得这个对象--&gt;&lt;alias name=&quot;user&quot; alias=&quot;user6&quot;/&gt; 5.2 Bean配置12345678&lt;bean id=&quot;user&quot; class=&quot;com.study.pojo.User&quot; name=&quot;user2 user3, user4; user5&quot;&gt; id: bean的唯一标识符, 也就是相当于我们学的对象名 class: bean 对应的全限定名(包名+类型) name: 也就是别名, 可以同时取多个别名--&gt;&lt;bean id=&quot;user&quot; class=&quot;com.study.pojo.User&quot; name=&quot;user2 user3, user4; user5&quot;&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;1234&quot;/&gt;&lt;/bean&gt; 5.3 import一般用于团队开发, 可将多个配置文件导入合并为一个 假如有多人开发, 各个负责不同的类, 不同的类需要注册不同的bean中, 可使用import将所有人的beans.xml合并为一个总的 使用时, 直接使用总的配置即可 applicationContext.xml 123&lt;import resource=&quot;beans.xml&quot;/&gt;&lt;import resource=&quot;beans2.xml&quot;/&gt;&lt;import resource=&quot;beans3.xml&quot;/&gt; 1ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); 6. 依赖注入6.1 构造器注入前面说过 6.2 Set方式注入(重点) 依赖注入: Set注入 依赖: bean对象的创建依赖容器 注入: bean对象中的所有属性, 由容器来注入 [环境搭建] 复杂类型 1234567891011public class Address &#123; private String address; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 真实测试对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Student &#123; private String name; private Address address; private String[] books; private List&lt;String&gt; hobbys; private Map&lt;String, String&gt; card; private Set&lt;String&gt; games; private String wife; private Properties info; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Address getAddress() &#123; return address; &#125; public void setAddress(Address address) &#123; this.address = address; &#125; public String[] getBooks() &#123; return books; &#125; public void setBooks(String[] books) &#123; this.books = books; &#125; public List&lt;String&gt; getHobbys() &#123; return hobbys; &#125; public void setHobbys(List&lt;String&gt; hobbys) &#123; this.hobbys = hobbys; &#125; public Map&lt;String, String&gt; getCard() &#123; return card; &#125; public void setCard(Map&lt;String, String&gt; card) &#123; this.card = card; &#125; public Set&lt;String&gt; getGames() &#123; return games; &#125; public void setGames(Set&lt;String&gt; games) &#123; this.games = games; &#125; public String getWife() &#123; return wife; &#125; public void setWife(String wife) &#123; this.wife = wife; &#125; public Properties getInfo() &#123; return info; &#125; public void setInfo(Properties info) &#123; this.info = info; &#125; @Override public String toString() &#123; return &quot;Student&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, address=&quot; + address + &quot;, books=&quot; + Arrays.toString(books) + &quot;, hobbys=&quot; + hobbys + &quot;, card=&quot; + card + &quot;, games=&quot; + games + &quot;, wife=&#x27;&quot; + wife + &#x27;\\&#x27;&#x27; + &quot;, info=&quot; + info + &#x27;&#125;&#x27;; &#125;&#125; beans.xml 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--第一种, 普通值注入 value--&gt; &lt;bean name=&quot;student&quot; class=&quot;com.study.pojo.Student&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;StudentName&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; 测试类 1234567public class MyTest &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;); Student student = (Student) context.getBean(&quot;student&quot;); System.out.println(student.getName()); &#125;&#125; 完善注入信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;address&quot; class=&quot;com.study.pojo.Address&quot;&gt; &lt;property name=&quot;address&quot; value=&quot;广西&quot;/&gt; &lt;/bean&gt; &lt;bean name=&quot;student&quot; class=&quot;com.study.pojo.Student&quot;&gt; &lt;!--第一种, 普通值注入 value--&gt; &lt;property name=&quot;name&quot; value=&quot;StudentName&quot;/&gt; &lt;!--第二种 Bean注入, ref--&gt; &lt;property name=&quot;address&quot; ref=&quot;address&quot;/&gt; &lt;!--array--&gt; &lt;property name=&quot;books&quot;&gt; &lt;array&gt; &lt;value&gt;红楼梦&lt;/value&gt; &lt;value&gt;三国&lt;/value&gt; &lt;value&gt;西游&lt;/value&gt; &lt;value&gt;水浒&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;!--List--&gt; &lt;property name=&quot;hobbys&quot;&gt; &lt;list&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;value&gt;电影&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!--Map--&gt; &lt;property name=&quot;card&quot;&gt; &lt;map&gt; &lt;entry key=&quot;身份证&quot; value=&quot;14556516351&quot;/&gt; &lt;entry key=&quot;银行卡&quot; value=&quot;1564654135165&quot;/&gt; &lt;/map&gt; &lt;/property&gt; &lt;!--Set--&gt; &lt;property name=&quot;games&quot;&gt; &lt;set&gt; &lt;value&gt;LOL&lt;/value&gt; &lt;value&gt;CF&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;!--null--&gt; &lt;property name=&quot;wife&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;!--property--&gt; &lt;property name=&quot;info&quot;&gt; &lt;props&gt; &lt;prop key=&quot;学号&quot;&gt;20180000&lt;/prop&gt; &lt;prop key=&quot;姓名&quot;&gt;小明&lt;/prop&gt; &lt;prop key=&quot;性别&quot;&gt;男&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 6.3 拓展注入可以使用p命名空间和c命名空间 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:c=&quot;http://www.springframework.org/schema/c&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!--p命名空间 可以注入属性的值 property--&gt; &lt;bean id=&quot;user&quot; class=&quot;com.study.pojo.User&quot; p:name=&quot;小明&quot; p:age=&quot;18&quot;/&gt; &lt;!--c命名空间 通过构造器注入: construct-args--&gt; &lt;bean id=&quot;user2&quot; class=&quot;com.study.pojo.User&quot; c:name=&quot;小明2&quot; c:age=&quot;18&quot;/&gt;&lt;/beans&gt; 注意: 不能直接使用, 需要导入xml约束 12xmlns:p=&quot;http://www.springframework.org/schema/p&quot;xmlns:c=&quot;http://www.springframework.org/schema/c&quot; 6.4 bean的作用域 单例模式 (Spring默认机制) 1&lt;bean id=&quot;user&quot; class=&quot;com.study.pojo.User&quot; p:name=&quot;小明&quot; p:age=&quot;18&quot; scope=&quot;singleton&quot;/&gt; 原型模式: 每次从容器get的时候, 都会产生一个新对象 1&lt;bean id=&quot;user&quot; class=&quot;com.study.pojo.User&quot; p:name=&quot;小明&quot; p:age=&quot;18&quot; scope=&quot;prototype&quot;/&gt; 其余的request, session, application, 这些只能在web开发中使用到 7. bean的自动装配 自动装配是Spring满足bean依赖一种方式 Spring会在上下文中自动寻找, 并自动给bean装配属性 在Spring中有三种装配的方式 在xml中显式的配置 在java中显式配置 隐式的自动装配bean (重要) 7.1 环境People类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.study.pojo;/** * @author tch * @date 2021/04/12 16:26:47 **/public class People &#123; private String name; private Cat cat; private Dog dog; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Cat getCat() &#123; return cat; &#125; public void setCat(Cat cat) &#123; this.cat = cat; &#125; public Dog getDog() &#123; return dog; &#125; public void setDog(Dog dog) &#123; this.dog = dog; &#125; @Override public String toString() &#123; return &quot;com.study.pojo.People&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, cat=&quot; + cat + &quot;, dog=&quot; + dog + &#x27;&#125;&#x27;; &#125;&#125; Cat类 12345public class Cat &#123; public void shout() &#123; System.out.println(&quot;miao~&quot;); &#125;&#125; Dog类 12345public class Dog &#123; public void shout() &#123; System.out.println(&quot;wang~&quot;); &#125;&#125; 7.2 byName自动装配byName: 会在容器上下文中查找, 和 自己对象 set方法 后 值 对应的 bean id 1234&lt;!--byName: 会在容器上下文中查找, 和自己对象set方法后值对应的 bean id--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.study.pojo.People&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;&lt;/bean&gt; 7.3 byType 自动装配byType: 会在容器上下文中查找, 和自己对象 属性类型相同 的 bean 1234&lt;!--byType: 会在容器上下文中查找, 和自己对象属性类型相同的 bean--&gt;&lt;bean id=&quot;people&quot; class=&quot;com.study.pojo.People&quot; autowire=&quot;byType&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;小明&quot;/&gt;&lt;/bean&gt; 小结: byName: 需要保证所有 bean 的 id 唯一, 并且这个bean需要和自动注入的属性的 set方法一致 byType: 需要保证所有 bean的 class唯一, 并且这个bean需要和自动注入的属性的 类型一致 7.4 使用注解实现自动装配JDK1.5支持注解 Spring2.5就支持了 ![image-20210412203949251](5. Spring.assets/image-20210412203949251.png) 使用注解须知: 导入约束: context 约束 ==配置注解的支持:== &lt;context:annotation-config/&gt; 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; @Autowired注解 直接在属性上使用即可, 也可以在set方法上使用 使用Autowired, 可以不用再编写Set方法, 前提是这个自动装配的属性在ioc(Spring) 容器中存在, 且符合名字为byName 科普: 1@Nullable 字段标记了这个注解, 说明这个字段可以为null 123public @interface Autowired &#123; boolean required() default true;&#125; 测试代码 123456789public class People &#123; private String name; /*如果显式定义了Autowired的required属性为false, 说明对象可以为null, 否则不允许为空*/ @Autowired(required = false) private Cat cat; @Autowired private Dog dog;&#125; 如果@Autowired自动装配的环境复杂, 自动装配无法通过一个注解 @Autowired 完成时, 可以使用 @Qualifier(value = &quot;xxx&quot;) 去配合@Autowired 的使用, 指定一个唯一的bean对象注入 123456789101112public class People &#123; private String name; @Autowired @Qualifier(value = &quot;cat222&quot;) private Cat cat; @Autowired @Qualifier(value = &quot;dog222&quot;) private Dog dog;&#125; @Resource注解 1234567891011121314public class People &#123; private String name; @Resource(name = &quot;cat111&quot;) private Cat cat; @Resource private Dog dog; public String getName() &#123; return name; &#125;&#125; 小结 @Resource 和 @Autowired 的区别 都是用于自动装配, 都可以放在属性字段 @Autowired 通过byType的方式实现, 且必须要求这个对象存在 常用 @Resource 默认通过 byName 的方式实现, 如果找不到名字, 则通过byType实现, 如果两个都找不到的情况下 就报错 常用 执行顺序不同: @Autowired 通过byType的方式实现, @Resource 默认通过 byName的方式实现 8. 使用注解开发在使用spring4之后要使用注解开发, 必须要保证aop的包导入了 ![image-20210412215329084](5. Spring.assets/image-20210412215329084.png) 使用注解需要导入context约束, 增加注解的支持 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--配置注解的支持--&gt; &lt;context:annotation-config/&gt;&lt;/beans&gt; 8.1 bean8.2 属性如何注入12345678910@Component //等价于 &lt;bean id=&quot;user&quot; class=&quot;com.study.pojo.User&quot;/&gt; @Component 组件public class User &#123; public String name; @Value(&quot;1233&quot;) //相当于 &lt;property name=&quot;name&quot; value=&quot;213&quot;/&gt; public void setName(String name) &#123; this.name = name; &#125;&#125; 8.3 衍生的注解@Component 有几个衍生注解, 在web开发中, 会按照mvc三层架构分层 dao @Repository service @service controller @Controller 这四个注解功能都是一样, 都是代表将某个类注册到Spring中, 装配 bean 8.4 自动装配123@Autowired: 自动装配类型 通过名字 如果Autowired不能唯一自动装配上属性, 则需要通过 @Qualifier(value = &quot;xxx&quot;) @Nullable: 字段标记了这个注解, 说明这个字段可以为null @Resource: 自动装配 通过名字, 类型 8.5 作用域==@Scope(“prototype”)== 1234567891011@Component //等价于 &lt;bean id=&quot;user&quot; class=&quot;com.study.pojo.User&quot;/&gt; @Component 组件@Scope(&quot;prototype&quot;)public class User &#123; public String name; @Value(&quot;1233&quot;) //相当于 &lt;property name=&quot;name&quot; value=&quot;213&quot;/&gt; public void setName(String name) &#123; this.name = name; &#125;&#125; 8.6 小结xml与注解: xml更加万能, 适用于任何场合, 维护简单方便 注解 不是自己的类使用不了, 维护相对复杂 xml与注解最佳实践: xml用来管理bean 注解只负责完成属性的注入 我们在使用的过程中, 只需要主要一个问题: 必须让注解生效, 就需要注解的支持 12345&lt;!--配置注解的支持--&gt;&lt;context:annotation-config/&gt;&lt;!--指定扫描的包, 这个包下的注解就会生效--&gt;&lt;context:component-scan base-package=&quot;com.study&quot;/&gt; 9. 使用java的方式配置Spring我们现在要完全不使用Spring的xml配置了, 全权交给java来做 JavaConfig是Spring的一个子项目, 在spring4之后, 他成了一个核心功能 pojo User : 123456789101112131415161718192021//这里这个注解的意思, 就是说明这个类被Spring接管了, 注册到容器中@Componentpublic class User &#123; private String name; public String getName() &#123; return name; &#125; @Value(&quot;1323&quot;) // 属性注入值 public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 配置文件 : MyConfig.java 123456789101112131415// 这个也会被Spring容器托管, 注册到容器中, 因为他本身就是一个@Component// @Configuration代表这是一个配置类, 就和我们之前看的 beans.xml一样@Configuration@ComponentScan(&quot;com.study.pojo&quot;)@Import(MyConfig2.class)public class MyConfig &#123; //注册一个bean, 就相当于我们之前写的一个bean标签 //这个方法的名字, 就相当于bean标签中的id属性 //这个方法的返回值, 就相当于bean标签中的class属性 @Bean public User getUser() &#123; return new User(); //就是要返回要注入到bean的对象 &#125;&#125; MyConfig2.java 1234@Configurationpublic class MyConfig2 &#123;&#125; 测试类 123456789public class MyTest &#123; public static void main(String[] args) &#123; //如果完全使用了配置类方式去做, 就只能通过AnnotationConfig 上下文来获取容器, 通过配置类的class对象加载 ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class); User getUser = (User) context.getBean(&quot;getUser&quot;); System.out.println(getUser.getName()); &#125;&#125; 这种纯java的配置方式, 在spring boot中随处可见 10. 代理模式为什么要学代理模式? ​ 因为这就是SpringAOP的底层 [SpringAOP 和 SpringMVC] 代理模式分类: 静态代理 动态代理 10.1 静态代理角色分析: 抽象角色 : 一般会使用接口或者抽象类来解决 真实角色 : 被代理的角色 代理角色 : 代理真实角色, 代理真实角色后, 我们一般会做一些附属操作 客户 : 访问代理对象的人 代码步骤 : 接口 123public interface Rent &#123; public void rent();&#125; 真实角色 123456public class Host implements Rent &#123; @Override public void rent() &#123; System.out.println(&quot;房东要出租房子!&quot;); &#125;&#125; 代理角色 1234567891011121314151617181920public class Proxy &#123; private Host host; public Proxy() &#123; &#125; public Proxy(Host host) &#123; this.host = host; &#125; public void rent() &#123; seeHouse(); host.rent(); &#125; //看房 public void seeHouse() &#123; System.out.println(&quot;看房&quot;); &#125;&#125; 客户端访问代理角色 123456789101112public class Client &#123; public static void main(String[] args) &#123; //房东出租房子 Host host = new Host(); //代理, 中介帮房东出租房子, 但是, 代理角色一般会有一些附属操作 Proxy proxy = new Proxy(host); //你, 不用面对房东, 直接找中介即可 proxy.rent(); &#125;&#125; 代理模式好处: 可以使真实角色的操作更纯粹, 不用去关注一些公共的业务 公共业务就交给代理角色, 实现业务的分工 公共业务发生扩展的时候, 方便集中管理 缺点: 一个真实角色就会产生一个代理角色, 代码量会翻倍, 开发效率会变低 10.2 加深理解代码: 接口 : 123456789public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; 真实角色 123456789101112131415161718192021public class UserServiceImpl implements UserService &#123; @Override public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;修改了一个用户&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询一个用户&quot;); &#125;&#125; 代理角色 12345678910111213141516171819202122232425262728293031323334353637public class UserServiceProxy implements UserService &#123; private UserService userService; public void setUserService(UserService userService) &#123; this.userService = userService; &#125; @Override public void add() &#123; log(&quot;add&quot;); userService.add(); &#125; @Override public void delete() &#123; log(&quot;delete&quot;); userService.delete(); &#125; @Override public void update() &#123; log(&quot;update&quot;); userService.update(); &#125; @Override public void query() &#123; log(&quot;query&quot;); userService.query(); &#125; //日志方法 public void log(String msg) &#123; System.out.println(&quot;使用了&quot; + msg + &quot;方法&quot;); &#125;&#125; 客户端访问代理角色 123456789101112public class Client &#123; public static void main(String[] args) &#123; UserServiceImpl userService = new UserServiceImpl(); UserServiceProxy proxy = new UserServiceProxy(); proxy.setUserService(userService); proxy.add(); &#125;&#125; 聊聊AOP 10.3 动态代理 动态代理和静态代理角色一样 动态代理的代理类是动态生成的, 不是我们直接写好的 动态代理分成两大类: 基于接口的动态代理, 基于类的动态代理 基于接口 — JDK动态代理 [我们在这里使用] 基于类: cglib java字节码实现: javasist 需要了解两个类: Proxy: 代理, invocationHandler: 调用处理程序 **动态代理的好处 : ** 可以使真实角色的操作更纯粹, 不用去关注一些公共的业务 公共业务就交给代理角色, 实现业务的分工 公共业务发生扩展的时候, 方便集中管理 一个动态代理类代理的是一个接口, 一般就是对应的一类业务 一个动态代理类可以代理多个类, 只要是实现了同一个接口即可 11. AOP11.1 什么是AOP 11.2 AOP在Spring中的作用 11.3 使用Spring实现Aop **重点 : ** 使用AOP织入, 需要导入一个依赖包 12345&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.4&lt;/version&gt;&lt;/dependency&gt; 搭建环境: Log 1234567891011public class Log implements MethodBeforeAdvice &#123; /* * method 要执行的目标对象的方法 * args 参数 * target 目标对象 * */ @Override public void before(Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(target.getClass().getName() + &quot;的&quot; + method.getName() + &quot;被执行了&quot;); &#125;&#125; AfterLog 123456public class AfterLog implements AfterReturningAdvice &#123; @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable &#123; System.out.println(&quot;执行了&quot; + method.getName() + &quot;方法, 返回结果为&quot; + returnValue); &#125;&#125; UserService接口 123456789public interface UserService &#123; public void add(); public void delete(); public void update(); public void query();&#125; UserService实现类 123456789101112131415161718192021222324public class UserServiceImpl implements UserService &#123; @Override public void add() &#123; System.out.println(&quot;增加了一个用户&quot;); &#125; @Override public void delete() &#123; System.out.println(&quot;删除了一个用户&quot;); &#125; @Override public void update() &#123; System.out.println(&quot;更新了一个用户&quot;); &#125; @Override public void query() &#123; System.out.println(&quot;查询了一个用户&quot;); &#125;&#125; 11.3.1 方式1 使用Spring的API接口 ==主要SpringAPI接口实现== bean.xml 12345678910111213141516&lt;!--注册bean--&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.study.service.UserServiceImpl&quot;/&gt;&lt;bean id=&quot;log&quot; class=&quot;com.study.log.Log&quot;/&gt;&lt;bean id=&quot;afterLog&quot; class=&quot;com.study.log.AfterLog&quot;/&gt;&lt;!--方式1 : 使用原生Spring API接口--&gt;&lt;!--配置AOP: 需要导入aop的约束--&gt; &lt;aop:config&gt; &lt;!--切入点: expression:表达式, execution(要执行的位置! * * * * *)--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.study.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--执行环绕增加--&gt; &lt;aop:advisor advice-ref=&quot;log&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;afterLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:config&gt; 11.3.2 方式2 自定义类来实现AOP 主要是切面定义 DiyPointcut类 123456789public class DiyPointcut &#123; public void before() &#123; System.out.println(&quot;=========方法执行前=======&quot;); &#125; public void after() &#123; System.out.println(&quot;=========方法执行后=======&quot;); &#125;&#125; bean.xml 123456789101112&lt;!--方式2--&gt;&lt;bean id=&quot;diy&quot; class=&quot;com.study.diy.DiyPointcut&quot;/&gt;&lt;aop:config&gt; &lt;!--自定义切面, ref 要引用的类--&gt; &lt;aop:aspect ref=&quot;diy&quot;&gt; &lt;!--切入点--&gt; &lt;aop:pointcut id=&quot;point&quot; expression=&quot;execution(* com.study.service.UserServiceImpl.*(..))&quot;/&gt; &lt;!--通知--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;aop:after method=&quot;after&quot; pointcut-ref=&quot;point&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 11.3.3 方式3 使用注解实现 12345678910111213141516171819202122@Aspect //标注这个类是一个切面public class AnnotationPointCut &#123; @Before(&quot;execution( * com.study.service.UserServiceImpl.*(..))&quot;) public void before() &#123; System.out.println(&quot;===========方法执行前===========&quot;); &#125; @After(&quot;execution( * com.study.service.UserServiceImpl.*(..))&quot;) public void after() &#123; System.out.println(&quot;===========方法执行后===========&quot;); &#125; @Around(&quot;execution( * com.study.service.UserServiceImpl.*(..))&quot;) public void around(ProceedingJoinPoint jp) throws Throwable &#123; System.out.println(&quot;环绕前&quot;); //执行方法 Object proceed = jp.proceed(); System.out.println(&quot;环绕后&quot;); &#125;&#125; bean.xml 1234&lt;!--方式三--&gt;&lt;bean id=&quot;annotationPointCut&quot; class=&quot;com.study.diy.AnnotationPointCut&quot;/&gt;&lt;!--开启注解支持--&gt;&lt;aop:aspectj-autoproxy/&gt;","categories":[],"tags":[]}],"categories":[],"tags":[]}